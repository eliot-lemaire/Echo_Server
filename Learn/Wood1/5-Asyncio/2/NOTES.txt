Learn why blocking sockets can't handle multiple clients simultaneously and how non-blocking sockets with select()
enable basic concurrency. Understand the transition from sequential to event-driven programming.

    Explain why blocking sockets can only handle one client at a time.

    Set sockets to non-blocking mode and handle BlockingIOError.

    Use select() to monitor multiple sockets for readiness.

    Handle multiple concurrent clients with a single thread.

    Identify when a client has disconnected.

-----------------------------------------------------------------------------------------------------------------------------------------------------------

read_sockets, _, exception_sockets = select.select(sockets_list, [], sockets_list)

readable, writable, errored = select.select(read_list, write_list, error_list)

| Parameter    | What it means                                             | Example                                           |
| ------------ | --------------------------------------------------------- | ------------------------------------------------- |
| `read_list`  | sockets you want to check for *incoming data*             | `[server_socket, client_socket1, client_socket2]` |
| `write_list` | sockets you want to check if they’re *ready to send data* | `[]` (often unused)                               |
| `error_list` | sockets you want to check for *errors or disconnections*  | same as `read_list`                               |

select.select() is a function that watches multiple sockets and tells you which ones are ready for a certain operation — like reading or writing.

read_list .... are returning filtered lists.

-----------------------------------------------------------------------------------------------------------------------------------------------------------

server_socket = new client
client_socket = existing socket

---DEBUG SOCKET_LIST---
[<socket.socket fd=3, family=2, type=1, proto=0, laddr=('127.0.0.1', 9001)>] # Servers socket
[<socket.socket fd=4, family=2, type=1, proto=0, laddr=('127.0.0.1', 9001), raddr=('127.0.0.1', 35444)>] # client socket

| Part                        | Meaning                                                                                                                                                   |
| --------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `<socket.socket ...>`       | It’s showing a Python `socket` object.                                                                                                                    |
| `fd=3`                      | **File descriptor** — a unique integer given by the OS to identify the socket. Every open socket, file, or pipe has one. Your server socket got number 3. |
| `family=2`                  | Address family — `2` means **AF_INET**, i.e. IPv4.                                                                                                        |
| `type=1`                    | Type of socket — `1` means **SOCK_STREAM**, i.e. a TCP socket (not UDP).                                                                                  |
| `proto=0`                   | Protocol — `0` is the default for TCP.                                                                                                                    |
| `laddr=('127.0.0.1', 9001)` | **Local address** — the IP and port that this socket is bound to. So your server is listening on port `9001` of localhost.                                |

fd=3 # Server's socket
fd=4 # Client's server

For clients[notified_socket]

Nice — here’s a **very simple, concrete** walkthrough with actual example *values* so it’s obvious what’s stored where and why the lookup works.

---

### 1) After `accept()` (a client connects)

```python
client_socket, client_address = server_socket.accept()
```

Concrete example values:

* `server_socket` → `<socket fd=3>`
* `client_socket` → `<socket fd=4>` (a new socket object)
* `client_address` → `('192.168.1.10', 50500)`

Right after accept we do:

```python
sockets_list.append(client_socket)
clients[client_socket] = client_address
```

So the data structures **now** contain:

* `sockets_list` = `[ server_socket, client_socket ]`
  (i.e. `[<socket fd=3>, <socket fd=4>]`)

* `clients` = `{ <socket fd=4> : ('192.168.1.10', 50500) }`

> Note: the key in the dict is the *socket object* `<socket fd=4>`, not the address.

---

### 2) Later `select()` says which sockets are ready

`select.select(sockets_list, [], sockets_list)` returns, say:

* `read_sockets = [ client_socket ]`
  i.e. `[ <socket fd=4> ]`

Inside the loop:

```python
for notified_socket in read_sockets:
    # notified_socket is exactly the same object as client_socket
```

Concrete:

* `notified_socket` → `<socket fd=4>`

---

### 3) Lookup in the dict works because the object is identical

When you do:

```python
clients[notified_socket]
```

Python finds the entry with key `<socket fd=4>` and returns:

```python
('192.168.1.10', 50500)
```

So the print:

```python
print(f"Received from {clients[notified_socket]}: {data.decode()}")
```

becomes:

```
Received from ('192.168.1.10', 50500): hello
```

---

### 4) Why this works (one-line reason)

You stored the **same socket object** as a key in `clients` when the client connected; `select()` later gives you that *same object* back as `notified_socket`. Keys match by object identity, so the dict lookup succeeds.

---

### 5) What happens on disconnect

If the client disconnects:

* `recv()` returns `b''` → you `del clients[client_socket]` and `sockets_list.remove(client_socket)` and `client_socket.close()`.
  If a new client later connects, `accept()` will create a **new** socket object (different fd/object), so it will be a different key in `clients`.

---

### Small demo you can run inside your server (shows equality)

```python
client_socket, client_address = server_socket.accept()
print("client_socket id:", id(client_socket))         # e.g. 1001
sockets_list.append(client_socket)
clients[client_socket] = client_address
# ... later, after select()
for notified_socket in read_sockets:
    print("notified_socket id:", id(notified_socket)) # prints same id 1001
    print(notified_socket is client_socket)           # True
    print("lookup:", clients[notified_socket])        # ('192.168.1.10', 50500)
```

---

If you want, I can show the **exact sequence** with two clients (give them different IPs/ports) so you can see how `sockets_list` and `clients` look after each event.


